# model_trainer.py
# Purpose: To load a pre-processed training dataset, train a Random Forest classifier,
#          evaluate its performance, and save the finalized model and its optimal
#          prediction threshold for use in the live backtesting agent.

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
import joblib
from sklearn.ensemble import RandomForestClassifier
from sklearn.metrics import f1_score, classification_report, roc_auc_score, confusion_matrix
import config # Your custom configuration file

# --------------------------------------------------------------------------
# DISCLAIMER
# --------------------------------------------------------------------------
# This model trainer is specifically configured for the features and market
# dynamics of the Nasdaq 100 (NQ) on a 1-minute timeframe.
#
# DO NOT use the model generated by this script on a different asset (e.g., JPN index)
# or a different timeframe (e.g., 5-minute) without completely retraining it on a
# new dataset generated specifically for that asset/timeframe.
#
# The feature set, model hyperparameters, and optimal threshold are all highly
# specific to the training data.
# --------------------------------------------------------------------------

class ModelTrainer:
    """
    An agent responsible for training, evaluating, and saving the trading model.
    """
    def __init__(self, data_path):
        """
        Initializes the trainer with the path to the feature dataset.
        """
        try:
            self.df = pd.read_csv(data_path)
            print(f"Successfully loaded dataset with {len(self.df)} trades from '{data_path}'.")
        except FileNotFoundError:
            print(f"Error: Training data file not found at '{data_path}'.")
            raise

    def prepare_data(self):
        """
        Prepares the data by cleaning, selecting features, and performing a
        time-series split for training and validation.
        """
        print("Preparing data for training...")
        # We only train on clear Wins (TP) and clear Losses (SL)
        self.df = self.df[self.df['outcome'].isin(['TP', 'SL'])].copy()
        
        # Use the feature list from the config file
        self.X = self.df[config.MODEL_FEATURES]
        self.y = self.df['target']
        
        # Perform a time-series split (80% train, 20% validation/test)
        split_index = int(len(self.X) * config.TRAIN_TEST_SPLIT_RATIO)
        self.X_train, self.X_test = self.X.iloc[:split_index], self.X.iloc[split_index:]
        self.y_train, self.y_test = self.y.iloc[:split_index], self.y.iloc[split_index:]

        print(f"Training set size: {len(self.X_train)} trades")
        print(f"Test set size: {len(self.X_test)} trades")

    def train_model(self):
        """
        Trains the Random Forest classifier on the training data.
        """
        print("\nTraining Random Forest model...")
        self.model = RandomForestClassifier(
            n_estimators=config.RF_N_ESTIMATORS,
            class_weight='balanced', # Handles imbalance between wins and losses
            random_state=config.RF_RANDOM_STATE,
            n_jobs=-1
        )
        self.model.fit(self.X_train, self.y_train)
        print("Model training complete.")

    def find_optimal_threshold(self):
        """
        Finds the optimal prediction threshold on the test set to maximize F1-score.
        """
        print("\nFinding optimal prediction threshold...")
        y_pred_proba = self.model.predict_proba(self.X_test)[:, 1]
        
        thresholds = config.THRESHOLD_SEARCH_RANGE
        f1_scores = [f1_score(self.y_test, (y_pred_proba >= t).astype(int)) for t in thresholds]
        
        self.optimal_threshold = thresholds[np.argmax(f1_scores)]
        print(f"Optimal threshold found: {self.optimal_threshold:.2f}")

    def evaluate_model(self):
        """
        Evaluates the model on the test set using the optimal threshold and
        generates a classification report and visualizations.
        """
        print("\nEvaluating model with the new optimal threshold...")
        y_pred_proba = self.model.predict_proba(self.X_test)[:, 1]
        y_pred_final = (y_pred_proba >= self.optimal_threshold).astype(int)

        print("\n--- Classification Report (Test Set) ---")
        print(classification_report(self.y_test, y_pred_final, target_names=["Loss (0)", "Win (1)"]))
        print(f"AUC Score: {roc_auc_score(self.y_test, y_pred_proba):.4f}")
        print("---------------------------------------------")

        # Visualize Confusion Matrix
        cm = confusion_matrix(self.y_test, y_pred_final)
        plt.figure(figsize=(6, 5))
        sns.heatmap(cm, annot=True, fmt="d", cmap="Blues", xticklabels=["Pred Loss", "Pred Win"], yticklabels=["True Loss", "True Win"])
        plt.title("Confusion Matrix (Test Set)")
        plt.xlabel("Predicted Label")
        plt.ylabel("True Label")
        plt.tight_layout()
        plt.show()

        # Visualize Feature Importance
        importances = pd.DataFrame({
            'feature': self.X.columns,
            'importance': self.model.feature_importances_
        }).sort_values('importance', ascending=False).head(15)

        print("\n--- Top 15 Feature Importances ---")
        print(importances)
        
        plt.figure(figsize=(10, 8))
        sns.barplot(x='importance', y='feature', data=importances, palette='viridis')
        plt.title('Top 15 Feature Importances')
        plt.xlabel('Importance Score')
        plt.ylabel('Feature')
        plt.tight_layout()
        plt.show()

    def save_model_and_threshold(self, model_path, threshold_path):
        """
        Saves the trained model and the optimal threshold to disk.
        """
        print("\nSaving model and threshold...")
        joblib.dump(self.model, model_path)
        joblib.dump(self.optimal_threshold, threshold_path)
        print(f"Model saved to '{model_path}'")
        print(f"Threshold saved to '{threshold_path}'")

def main():
    """Main function to run the model training pipeline."""
    print("--- Starting Model Training Pipeline ---")
    
    trainer = ModelTrainer(config.ML_FEATURES_FILE)
    
    trainer.prepare_data()
    trainer.train_model()
    trainer.find_optimal_threshold()
    trainer.evaluate_model()
    trainer.save_model_and_threshold(config.MODEL_PATH, config.THRESHOLD_PATH)
    
    print("\n--- Model Training Pipeline Complete ---")

if __name__ == "__main__":
    main()